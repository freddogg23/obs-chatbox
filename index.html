// ====== Twitch creds (sessionStorage) ======
const CREDS_KEY = "twitch_creds_v1";

function getCreds() {
  try { return JSON.parse(sessionStorage.getItem(CREDS_KEY) || "null"); }
  catch { return null; }
}

function setCreds(clientId, token) {
  sessionStorage.setItem(CREDS_KEY, JSON.stringify({ clientId, token }));
}

function clearCreds() {
  sessionStorage.removeItem(CREDS_KEY);
}

// Call this from your settings menu "Save" button:
function saveCredsFromInputs() {
  const clientId = document.getElementById("twitchClientId").value.trim();
  const token = document.getElementById("twitchToken").value.trim();
  if (!clientId || !token) throw new Error("Missing Client ID or Token");
  setCreds(clientId, token);
}

// ====== Twitch API helpers ======
async function twitchFetch(url) {
  const creds = getCreds();
  if (!creds?.clientId || !creds?.token) throw new Error("No Twitch creds in session");

  const r = await fetch(url, {
    headers: {
      "Client-ID": creds.clientId,
      "Authorization": `Bearer ${creds.token}`,
    },
    cache: "no-store"
  });

  if (!r.ok) {
    const text = await r.text().catch(()=> "");
    throw new Error(`Twitch API ${r.status}: ${text || r.statusText}`);
  }
  return await r.json();
}

async function getBroadcasterId(login) {
  const data = await twitchFetch(`https://api.twitch.tv/helix/users?login=${encodeURIComponent(login)}`);
  const id = data?.data?.[0]?.id;
  if (!id) throw new Error("Could not resolve broadcaster_id");
  return id;
}

// ====== Badge cache ======
let badgeCache = {
  global: new Map(),   // setId -> Map(version -> imageUrl)
  channel: new Map(),  // setId -> Map(version -> imageUrl)
  loadedFor: null
};

function ingestBadges(apiData, targetMap) {
  // apiData.data: [{ set_id, versions:[{id, image_url_1x, image_url_2x, image_url_4x}, ...] }, ...]
  for (const set of (apiData?.data || [])) {
    const setId = set.set_id;
    const verMap = new Map();
    for (const v of (set.versions || [])) {
      // pick 2x (good balance); you can switch to 4x if you want
      verMap.set(v.id, v.image_url_2x || v.image_url_1x || v.image_url_4x);
    }
    targetMap.set(setId, verMap);
  }
}

async function loadBadgesForChannel(login) {
  const broadcasterId = await getBroadcasterId(login);
  const [globalBadges, channelBadges] = await Promise.all([
    twitchFetch("https://api.twitch.tv/helix/chat/badges/global"),
    twitchFetch(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${encodeURIComponent(broadcasterId)}`)
  ]);

  badgeCache.global = new Map();
  badgeCache.channel = new Map();
  ingestBadges(globalBadges, badgeCache.global);
  ingestBadges(channelBadges, badgeCache.channel);
  badgeCache.loadedFor = login;
}

// Convert IRC tags.badges into image URLs
// tags.badges might be { subscriber:"6", moderator:"1", ... }
function getBadgeImgUrlsFromTags(tags) {
  const badges = tags?.badges || {};
  const urls = [];

  for (const [setId, version] of Object.entries(badges)) {
    // channel badges override global if present
    const chanSet = badgeCache.channel.get(setId);
    const globSet = badgeCache.global.get(setId);

    const url =
      chanSet?.get(version) ||
      globSet?.get(version) ||
      chanSet?.get("1") ||
      globSet?.get("1");

    if (url) urls.push({ setId, url });
  }

  return urls;
}
