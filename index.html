<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OBS Twitch Chatbox (Menu + Twitch Badges + 7TV)</title>

<style>
  :root{
    --font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    --font-size: 24px;
    --line-height: 1.25;
    --gap: 10px;

    --msg-bg: rgba(0,0,0,0.35);
    --radius: 14px;
    --padY: 10px;
    --padX: 14px;

    --shadow: 0 6px 22px rgba(0,0,0,0.35);
    --text-shadow: 0 2px 8px rgba(0,0,0,0.6);

    --emote-size: 34px;
    --fade-ms: 220;
  }

  html,body{margin:0;height:100%;background:transparent;overflow:hidden;font-family:var(--font-family)}
  #wrap{position:absolute;inset:0;display:flex;align-items:flex-end;justify-content:flex-start;padding:12px;box-sizing:border-box}
  #chat{width:100%;display:flex;flex-direction:column;gap:var(--gap);pointer-events:none}

  .msg{
    display:flex;gap:10px;background:var(--msg-bg);border-radius:var(--radius);
    padding:calc(var(--padY)*1px) calc(var(--padX)*1px);
    box-shadow:var(--shadow);
    backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);
    opacity:0;transform:translateY(10px);
    transition:opacity var(--fade-ms)ms ease,transform var(--fade-ms)ms ease;
  }
  .msg.show{opacity:1;transform:translateY(0)}

  .left{display:flex;flex-direction:column;gap:6px;min-width:0;width:100%}
  .topline{display:flex;align-items:center;gap:8px;flex-wrap:wrap;min-width:0}

  .badges{display:flex;gap:4px;align-items:center}
  img.badgeImg{
    width:18px;height:18px;border-radius:4px;
    vertical-align:-4px;
    image-rendering:auto;
    filter: drop-shadow(0 1px 4px rgba(0,0,0,0.35));
  }
  .badgeText{
    font-size:12px;line-height:1;padding:2px 6px;border-radius:999px;
    background:rgba(255,255,255,0.14);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
  }

  .name{
    font-size:var(--font-size);line-height:var(--line-height);
    font-weight:800;text-shadow:var(--text-shadow);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:55%;
  }

  .text{
    font-size:var(--font-size);line-height:var(--line-height);
    font-weight:600;text-shadow:var(--text-shadow);
    word-break:break-word;overflow-wrap:anywhere;min-width:0;
  }

  img.emote{
    width: var(--emote-size);
    height: var(--emote-size);
    vertical-align: -8px;
    margin: 0 2px;
  }

  #pill{
    position:absolute;left:10px;top:10px;z-index:40;
    font-size:12px;padding:8px 10px;border-radius:999px;
    background:rgba(0,0,0,0.45);color:rgba(255,255,255,0.95);
    box-shadow:0 10px 28px rgba(0,0,0,0.35);
    backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
    max-width:calc(100% - 20px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
    pointer-events:none;
  }

  /* Menu */
  #menuToggle{
    position:absolute;top:10px;right:10px;z-index:50;
    width:44px;height:44px;border-radius:14px;border:0;
    background:rgba(0,0,0,0.45);color:#fff;cursor:pointer;
    box-shadow:0 10px 28px rgba(0,0,0,0.45);
    backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
  }
  #menu{
    position:absolute;top:64px;right:10px;z-index:50;
    width:410px;max-height:calc(100% - 80px);overflow:auto;
    border-radius:18px;background:rgba(12,12,12,0.80);
    color:rgba(255,255,255,0.95);
    box-shadow:0 18px 50px rgba(0,0,0,0.55);
    backdrop-filter:blur(14px);-webkit-backdrop-filter:blur(14px);
    padding:14px;display:none;pointer-events:auto;
  }
  #menu.open{display:block}

  .mTitle{font-weight:900;display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .mRow{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px}
  .mRow.full{grid-template-columns:1fr}
  label{font-size:12px;opacity:.9;display:block;margin-bottom:6px}
  input,select,textarea{
    width:100%;box-sizing:border-box;border-radius:12px;border:1px solid rgba(255,255,255,0.12);
    background:rgba(255,255,255,0.06);color:#fff;padding:10px;outline:none;
  }
  input[type="color"]{padding:0;height:42px}
  textarea{min-height:80px;resize:vertical;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.3}
  .btnRow{display:flex;gap:10px;margin-top:10px}
  .btn{
    flex:1;cursor:pointer;border:0;border-radius:14px;padding:10px 12px;
    font-weight:900;color:#fff;background:rgba(255,255,255,0.12);
  }
  .btn:hover{background:rgba(255,255,255,0.18)}
  .hint{font-size:12px;opacity:.82;line-height:1.25;margin-top:8px}
  .divider{height:1px;background:rgba(255,255,255,0.10);margin:12px 0}
  .warn{font-size:12px;opacity:.85;line-height:1.25;background:rgba(255,196,0,0.10);border:1px solid rgba(255,196,0,0.15);padding:10px;border-radius:12px}
</style>
</head>

<body>
  <div id="wrap"><div id="chat"></div></div>
  <div id="pill">starting…</div>

  <button id="menuToggle" title="Settings">⚙️</button>

  <div id="menu">
    <div class="mTitle">
      <div>Chatbox Settings</div>
      <div id="status" style="font-size:12px;opacity:.85;">idle</div>
    </div>

    <div class="warn">
      <b>Twitch Badges:</b> To show real badge images, enter <b>Client ID</b> + <b>App Access Token</b> below.
      They are stored in <b>sessionStorage</b> only (you must paste once per OBS session). Tokens are not put in the URL.
    </div>

    <div class="mRow full">
      <div><label>Channel (no @)</label><input id="channel"></div>
    </div>

    <div class="mRow">
      <div><label>Message text color</label><input id="textColor" type="color"></div>
      <div><label>Background opacity</label><input id="bgOpacity" type="number" min="0" max="1" step="0.05"></div>
    </div>

    <div class="mRow">
      <div><label>Font size (px)</label><input id="fontSize" type="number" min="10" max="90" step="1"></div>
      <div><label>Emote size (px)</label><input id="emoteSize" type="number" min="12" max="96" step="1"></div>
    </div>

    <div class="mRow">
      <div><label>Max messages</label><input id="maxMessages" type="number" min="1" max="50" step="1"></div>
      <div><label>Message lifetime (ms)</label><input id="ttlMs" type="number" min="2000" max="600000" step="500"></div>
    </div>

    <div class="mRow">
      <div><label>Show badges</label>
        <select id="showBadges"><option value="1">Yes</option><option value="0">No</option></select>
      </div>
      <div><label>Badge mode</label>
        <select id="badgeMode">
          <option value="twitch">Twitch images (needs creds)</option>
          <option value="text">Text (BC/MOD/VIP/SUB)</option>
        </select>
      </div>
    </div>

    <div class="mRow">
      <div><label>Enable 7TV</label>
        <select id="enable7tv"><option value="1">Yes</option><option value="0">No</option></select>
      </div>
      <div><label>7TV set</label>
        <select id="sevenTvMode"><option value="channel">Channel</option><option value="global">Global</option><option value="both">Both</option></select>
      </div>
    </div>

    <div class="mRow full">
      <div>
        <label>Special name colors JSON (optional)</label>
        <textarea id="specialColors" placeholder='{"someuser":"#ff00ff"}'></textarea>
        <div class="hint">Optional. If empty, Twitch name colors are used.</div>
      </div>
    </div>

    <div class="divider"></div>

    <div class="mRow">
      <div>
        <label>Twitch Client ID</label>
        <input id="twitchClientId" placeholder="paste client id">
      </div>
      <div>
        <label>Twitch App Access Token</label>
        <input id="twitchToken" placeholder="paste access token">
      </div>
    </div>

    <div class="btnRow">
      <button class="btn" id="saveCreds">Save creds</button>
      <button class="btn" id="clearCreds">Clear creds</button>
    </div>

    <div class="btnRow">
      <button class="btn" id="reloadBadges">Reload badges</button>
      <button class="btn" id="copy">Copy URL</button>
    </div>

    <div class="btnRow">
      <button class="btn" id="apply">Apply</button>
      <button class="btn" id="reset">Reset</button>
    </div>

    <div class="btnRow">
      <button class="btn" id="hideMenu">Hide menu</button>
      <button class="btn" id="showMenu">Show menu</button>
    </div>

    <div class="hint">
      “Copy URL” copies your configuration hash (safe). Tokens are never included.
    </div>
  </div>

<script>
  // ==========================
  // Utilities
  // ==========================
  const $ = (id)=>document.getElementById(id);
  const chatEl = $("chat");
  const pill = $("pill");
  const statusEl = $("status");
  const qs = new URLSearchParams(location.search);

  const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
  const esc=(s)=>(s??"").toString()
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");

  function setStatus(t){
    statusEl.textContent = t;
    pill.textContent = t;
    console.log(t);
  }

  // ==========================
  // Config (query defaults + hash override)
  // ==========================
  const DEFAULTS = {
    channel: (qs.get("channel") || "freddogg23").replace(/^@/,"").toLowerCase(),
    text: (qs.get("text") || "ffffff").replace("#",""),
    bg: parseFloat(qs.get("bg") ?? "0.35"),
    size: parseInt(qs.get("size") ?? "24", 10),
    emote: parseInt(qs.get("emote") ?? "34", 10),
    ttl: parseInt(qs.get("ttl") ?? "16000", 10),
    max: parseInt(qs.get("max") ?? "10", 10),
    badges: (qs.get("badges") ?? "1"),
    badgeMode: (qs.get("badgeMode") ?? "twitch"),
    seven: (qs.get("seven") ?? "1"),
    sevenMode: (qs.get("sevenMode") ?? "channel"),
    special: (qs.get("special") ?? ""),
    menu: (qs.get("menu") ?? "1")
  };

  function parseHash(){
    const h = (location.hash || "").replace(/^#/, "");
    const out = {};
    if (!h) return out;
    for (const part of h.split("&")){
      const [k,v] = part.split("=");
      if (!k) continue;
      out[decodeURIComponent(k)] = decodeURIComponent(v ?? "");
    }
    return out;
  }

  function getConfig(){
    const h = parseHash();
    const cfg = {...DEFAULTS, ...h};

    cfg.channel = (cfg.channel || "freddogg23").replace(/^@/,"").toLowerCase();
    const hex = (cfg.text || "ffffff").replace("#","").trim();
    cfg.text = /^[0-9a-f]{6}$/i.test(hex) ? hex.toLowerCase() : "ffffff";

    cfg.bg = clamp(parseFloat(cfg.bg ?? 0.35), 0, 1);
    cfg.size = clamp(parseInt(cfg.size ?? 24,10) || 24, 10, 90);
    cfg.emote = clamp(parseInt(cfg.emote ?? 34,10) || 34, 12, 96);
    cfg.ttl = clamp(parseInt(cfg.ttl ?? 16000,10) || 16000, 2000, 600000);
    cfg.max = clamp(parseInt(cfg.max ?? 10,10) || 10, 1, 50);

    cfg.badges = (cfg.badges === "0" ? "0" : "1");
    cfg.badgeMode = (cfg.badgeMode === "text" ? "text" : "twitch");

    cfg.seven = (cfg.seven === "0" ? "0" : "1");
    cfg.sevenMode = (cfg.sevenMode === "global" || cfg.sevenMode === "both") ? cfg.sevenMode : "channel";

    cfg.special = cfg.special || "";
    return cfg;
  }

  function applyCss(cfg){
    document.documentElement.style.setProperty("--msg-bg", `rgba(0,0,0,${cfg.bg})`);
    document.documentElement.style.setProperty("--font-size", `${cfg.size}px`);
    document.documentElement.style.setProperty("--emote-size", `${cfg.emote}px`);
  }

  function fillMenu(cfg){
    $("channel").value = cfg.channel;
    $("textColor").value = "#" + cfg.text;
    $("bgOpacity").value = cfg.bg;
    $("fontSize").value = cfg.size;
    $("emoteSize").value = cfg.emote;
    $("maxMessages").value = cfg.max;
    $("ttlMs").value = cfg.ttl;
    $("showBadges").value = cfg.badges;
    $("badgeMode").value = cfg.badgeMode;
    $("enable7tv").value = cfg.seven;
    $("sevenTvMode").value = cfg.sevenMode;
    $("specialColors").value = cfg.special || "";
  }

  function readMenu(){
    const hex = ($("textColor").value || "#ffffff").replace("#","");
    const specialRaw = ($("specialColors").value || "").trim();
    return {
      channel: ($("channel").value || "freddogg23").trim().replace(/^@/,"").toLowerCase(),
      text: /^[0-9a-f]{6}$/i.test(hex) ? hex.toLowerCase() : "ffffff",
      bg: clamp(parseFloat($("bgOpacity").value ?? "0.35"), 0, 1),
      size: clamp(parseInt($("fontSize").value ?? "24",10) || 24, 10, 90),
      emote: clamp(parseInt($("emoteSize").value ?? "34",10) || 34, 12, 96),
      max: clamp(parseInt($("maxMessages").value ?? "10",10) || 10, 1, 50),
      ttl: clamp(parseInt($("ttlMs").value ?? "16000",10) || 16000, 2000, 600000),
      badges: $("showBadges").value === "0" ? "0" : "1",
      badgeMode: $("badgeMode").value === "text" ? "text" : "twitch",
      seven: $("enable7tv").value === "0" ? "0" : "1",
      sevenMode: ($("sevenTvMode").value === "global" || $("sevenTvMode").value === "both") ? $("sevenTvMode").value : "channel",
      special: specialRaw
    };
  }

  function writeHash(cfg){
    const parts = [];
    const put = (k,v)=> parts.push(encodeURIComponent(k) + "=" + encodeURIComponent(String(v)));
    put("channel", cfg.channel);
    put("text", cfg.text);
    put("bg", cfg.bg);
    put("size", cfg.size);
    put("emote", cfg.emote);
    put("max", cfg.max);
    put("ttl", cfg.ttl);
    put("badges", cfg.badges);
    put("badgeMode", cfg.badgeMode);
    put("seven", cfg.seven);
    put("sevenMode", cfg.sevenMode);
    if ((cfg.special || "").trim()) put("special", cfg.special.trim());
    location.hash = parts.join("&");
  }

  async function copyUrl(){
    const url = location.origin + location.pathname + location.search + location.hash;
    try{
      await navigator.clipboard.writeText(url);
      setStatus("copied URL ✅");
    }catch(e){
      prompt("Copy this URL:", url);
    }
  }

  // ==========================
  // Session-only Twitch creds
  // ==========================
  const CREDS_KEY = "twitch_creds_session_v1";

  function getCreds(){
    try{ return JSON.parse(sessionStorage.getItem(CREDS_KEY) || "null"); }
    catch{ return null; }
  }
  function setCreds(clientId, token){
    sessionStorage.setItem(CREDS_KEY, JSON.stringify({ clientId, token }));
  }
  function clearCreds(){
    sessionStorage.removeItem(CREDS_KEY);
  }
  function credsPresent(){
    const c = getCreds();
    return !!(c?.clientId && c?.token);
  }

  function fillCredInputs(){
    const c = getCreds();
    $("twitchClientId").value = c?.clientId || "";
    $("twitchToken").value = c?.token || "";
  }

  // ==========================
  // Twitch API + badge cache (real images)
  // ==========================
  let badgeCache = {
    global: new Map(),   // setId -> Map(version -> imageUrl)
    channel: new Map(),  // setId -> Map(version -> imageUrl)
    loadedFor: null
  };

  async function twitchFetch(url){
    const creds = getCreds();
    if (!creds?.clientId || !creds?.token) throw new Error("No Twitch creds (Client ID/Token)");

    const r = await fetch(url, {
      headers: {
        "Client-ID": creds.clientId,
        "Authorization": `Bearer ${creds.token}`
      },
      cache: "no-store"
    });

    if (!r.ok){
      const text = await r.text().catch(()=> "");
      throw new Error(`Twitch API ${r.status}: ${text || r.statusText}`);
    }
    return await r.json();
  }

  async function getBroadcasterId(login){
    const data = await twitchFetch(`https://api.twitch.tv/helix/users?login=${encodeURIComponent(login)}`);
    const id = data?.data?.[0]?.id;
    if (!id) throw new Error("Could not resolve broadcaster_id");
    return id;
  }

  function ingestBadges(apiData, targetMap){
    for (const set of (apiData?.data || [])){
      const setId = set.set_id;
      const verMap = new Map();
      for (const v of (set.versions || [])){
        // prefer 2x
        verMap.set(v.id, v.image_url_2x || v.image_url_1x || v.image_url_4x);
      }
      targetMap.set(setId, verMap);
    }
  }

  async function loadBadgesForChannel(login){
    if (!credsPresent()) throw new Error("Missing creds");

    const broadcasterId = await getBroadcasterId(login);
    const [globalBadges, channelBadges] = await Promise.all([
      twitchFetch("https://api.twitch.tv/helix/chat/badges/global"),
      twitchFetch(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${encodeURIComponent(broadcasterId)}`)
    ]);

    badgeCache.global = new Map();
    badgeCache.channel = new Map();
    ingestBadges(globalBadges, badgeCache.global);
    ingestBadges(channelBadges, badgeCache.channel);
    badgeCache.loadedFor = login;
    return { globalSets: badgeCache.global.size, channelSets: badgeCache.channel.size };
  }

  function getBadgeImgUrlsFromTags(tags){
    const badges = tags?.badges || {};
    const urls = [];

    for (const [setId, version] of Object.entries(badges)){
      const chanSet = badgeCache.channel.get(setId);
      const globSet = badgeCache.global.get(setId);

      const url =
        chanSet?.get(version) ||
        globSet?.get(version) ||
        chanSet?.get("1") ||
        globSet?.get("1");

      if (url) urls.push({ setId, url, version });
    }
    return urls;
  }

  // ==========================
  // 7TV
  // ==========================
  const sevenTvMap = new Map();
  let sevenTvReady = false;

  async function fetchJson(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }

  function pickSevenTvUrl(emote){
    const host = emote?.data?.host;
    if (!host?.url || !Array.isArray(host.files)) return null;
    const names = host.files.map(f => f.name);
    const pick =
      names.includes("4x.webp") ? "4x.webp" :
      names.includes("3x.webp") ? "3x.webp" :
      names.includes("2x.webp") ? "2x.webp" :
      names.includes("1x.webp") ? "1x.webp" :
      names.includes("4x.avif") ? "4x.avif" :
      names.includes("3x.avif") ? "3x.avif" :
      names.includes("2x.avif") ? "2x.avif" :
      names.includes("1x.avif") ? "1x.avif" :
      names[0];
    return `https:${host.url}/${pick}`;
  }

  async function load7tv(login, mode){
    sevenTvMap.clear();
    sevenTvReady = false;

    const wantsGlobal = (mode === "global" || mode === "both");
    const wantsChannel = (mode === "channel" || mode === "both");

    try{
      if (wantsGlobal){
        const global = await fetchJson("https://7tv.io/v3/emote-sets/global");
        for (const e of (global?.emotes || [])){
          const url = pickSevenTvUrl(e);
          if (e?.name && url) sevenTvMap.set(e.name, url);
        }
      }
      if (wantsChannel){
        const user = await fetchJson(`https://7tv.io/v3/users/twitch/${encodeURIComponent(login)}`);
        const emotes = user?.emote_set?.emotes || [];
        for (const e of emotes){
          const url = pickSevenTvUrl(e);
          if (e?.name && url) sevenTvMap.set(e.name, url);
        }
      }

      sevenTvReady = sevenTvMap.size > 0;
      return { ok: sevenTvReady, count: sevenTvMap.size };
    }catch(err){
      sevenTvReady = false;
      return { ok: false, count: 0, err: String(err?.message || err) };
    }
  }

  function render7tvTokens(text, cfg){
    if (cfg.seven !== "1" || !sevenTvReady || sevenTvMap.size === 0) return esc(text);
    const parts = text.split(/(\s+)/);
    return parts.map(tok => {
      if (/^\s+$/.test(tok)) return tok;
      const url = sevenTvMap.get(tok);
      if (!url) return esc(tok);
      return `<img class="emote" alt="${esc(tok)}" src="${url}" loading="lazy" />`;
    }).join("");
  }

  // ==========================
  // IRC parsing + name color
  // ==========================
  function decodeTag(v){
    return (v||"")
      .replaceAll("\\:", ";").replaceAll("\\s", " ")
      .replaceAll("\\\\", "\\").replaceAll("\\r", "\r").replaceAll("\\n", "\n");
  }
  function parseTags(tagPart){
    const tags = {};
    if (!tagPart) return tags;
    for (const pair of tagPart.split(";")){
      const i = pair.indexOf("=");
      if (i === -1) continue;
      tags[pair.slice(0,i)] = decodeTag(pair.slice(i+1));
    }
    return tags;
  }
  function parsePrivmsg(line){
    let tags = {};
    let rest = line;
    if (rest.startsWith("@")){
      const sp = rest.indexOf(" ");
      tags = parseTags(rest.slice(1, sp));
      rest = rest.slice(sp+1);
    }
    const m = rest.match(/^:([^ ]+)\s+PRIVMSG\s+#[^ ]+\s+:(.*)$/);
    if (!m) return null;
    const username = (m[1].split("!")[0]) || tags.login || "unknown";
    return { tags, username, message: m[2] ?? "" };
  }

  function parseBadges(badgesStr){
    const out = {};
    if (!badgesStr) return out;
    for (const p of badgesStr.split(",")){
      const [k,v] = p.split("/");
      if (k) out[k] = v || "1";
    }
    return out;
  }

  function getSpecialMap(cfg){
    if (!cfg.special) return {};
    try{ return JSON.parse(cfg.special) || {}; }catch(e){ return {}; }
  }
  function pickNameColor(username, tags, cfg){
    const map = getSpecialMap(cfg);
    const u = (username||"").toLowerCase();
    if (map[u]) return map[u];
    const c = tags?.color;
    if (c && /^#([0-9a-f]{6})$/i.test(c)) return c;
    return "#a7ffef";
  }

  // ==========================
  // Badge HTML
  // ==========================
  function roleTextBadges(tags){
    const b = tags?.badges || {};
    const list = [];
    if (b.broadcaster) list.push(["broadcaster","BC"]);
    if (b.moderator) list.push(["moderator","MOD"]);
    if (b.vip) list.push(["vip","VIP"]);
    if (b.subscriber || b.founder) list.push(["subscriber","SUB"]);
    return list;
  }

  function buildBadgesHtml(tags, cfg){
    if (cfg.badges !== "1") return "";

    if (cfg.badgeMode === "text"){
      const list = roleTextBadges(tags);
      if (!list.length) return "";
      return `<span class="badges">` + list.map(([k,t])=>`<span class="badgeText" title="${k}">${t}</span>`).join("") + `</span>`;
    }

    // Twitch image badges (requires loaded cache)
    const imgBadges = getBadgeImgUrlsFromTags(tags);
    if (!imgBadges.length) return "";
    return `<span class="badges">` + imgBadges
      .map(b => `<img class="badgeImg" src="${b.url}" alt="${esc(b.setId)}" title="${esc(b.setId + "/" + b.version)}" loading="lazy" />`)
      .join("") + `</span>`;
  }

  // ==========================
  // Render message
  // ==========================
  function addMessage({username, displayName, tags, message, cfg}){
    while (chatEl.children.length >= cfg.max) chatEl.removeChild(chatEl.firstChild);

    const textColor = "#" + cfg.text;
    const nameColor = pickNameColor(username, tags, cfg);
    const badgesHtml = buildBadgesHtml(tags, cfg);
    const bodyHtml = render7tvTokens(message, cfg);

    const el = document.createElement("div");
    el.className = "msg";
    el.innerHTML = `
      <div class="left">
        <div class="topline">
          ${badgesHtml}
          <div class="name" style="color:${nameColor}">${esc(displayName || username)}</div>
        </div>
        <div class="text" style="color:${textColor}">${bodyHtml}</div>
      </div>
    `;
    chatEl.appendChild(el);
    requestAnimationFrame(()=>el.classList.add("show"));

    setTimeout(()=>{
      el.classList.remove("show");
      setTimeout(()=>{ if (el.parentNode) el.parentNode.removeChild(el); }, 260);
    }, cfg.ttl);
  }

  // ==========================
  // Stable Twitch IRC WS (keepalive + backoff)
  // ==========================
  const WS_URL = "wss://irc-ws.chat.twitch.tv:443";
  let ws = null;
  let connToken = 0;

  let reconnectTimer = null;
  let backoffMs = 2000;
  const BACKOFF_MAX = 16000;

  let keepAliveTimer = null;

  function clearTimers(){
    if (reconnectTimer){ clearTimeout(reconnectTimer); reconnectTimer = null; }
    if (keepAliveTimer){ clearInterval(keepAliveTimer); keepAliveTimer = null; }
  }

  function detachAndClose(){
    if (!ws) return;
    try{
      ws.onopen = ws.onmessage = ws.onerror = ws.onclose = null;
      ws.close();
    }catch(e){}
    ws = null;
  }

  function scheduleReconnect(){
    clearTimers();
    const wait = backoffMs;
    backoffMs = Math.min(BACKOFF_MAX, backoffMs * 2);
    setStatus(`reconnecting in ${Math.round(wait/1000)}s…`);
    reconnectTimer = setTimeout(()=>connect(getConfig()), wait);
  }

  async function connect(cfg){
    connToken++;
    const token = connToken;

    clearTimers();
    detachAndClose();

    applyCss(cfg);

    // Load 7TV first (optional)
    let sevenInfo = "";
    if (cfg.seven === "1"){
      setStatus(`loading 7TV…`);
      const r = await load7tv(cfg.channel, cfg.sevenMode);
      if (token !== connToken) return;
      sevenInfo = r.ok ? `7TV=${r.count}` : `7TV=off`;
    } else {
      sevenTvReady = false;
      sevenTvMap.clear();
      sevenInfo = "7TV=off";
    }

    // Load badges if creds exist and mode = twitch
    let badgeInfo = "";
    if (cfg.badges === "1" && cfg.badgeMode === "twitch"){
      if (credsPresent()){
        try{
          setStatus(`loading badges…`);
          const b = await loadBadgesForChannel(cfg.channel);
          if (token !== connToken) return;
          badgeInfo = `badges=ok`;
        }catch(err){
          badgeInfo = `badges=fail`;
        }
      } else {
        badgeInfo = `badges=need-creds`;
      }
    } else {
      badgeInfo = (cfg.badgeMode === "text") ? "badges=text" : "badges=off";
    }

    setStatus(`connecting… #${cfg.channel} • ${sevenInfo} • ${badgeInfo}`);

    ws = new WebSocket(WS_URL);

    ws.onopen = ()=>{
      if (token !== connToken) return;

      backoffMs = 2000;

      ws.send("CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership");
      ws.send("PASS SCHMOOPIIE");
      ws.send("NICK justinfan" + Math.floor(1000 + Math.random()*9000));
      ws.send(`JOIN #${cfg.channel}`);

      keepAliveTimer = setInterval(()=>{
        try{
          if (ws && ws.readyState === WebSocket.OPEN){
            ws.send("PING :keepalive");
          }
        }catch(e){}
      }, 45000);
    };

    ws.onmessage = (ev)=>{
      if (token !== connToken) return;

      const lines = (ev.data||"").split("\r\n").filter(Boolean);
      for (const line of lines){
        if (line.startsWith("PING")){
          try{ ws.send("PONG :tmi.twitch.tv"); }catch(e){}
          continue;
        }

        if (line.includes(" JOIN #")){
          const sevenPart = (cfg.seven === "1") ? `7TV=${sevenTvMap.size}` : "7TV=off";
          const badgePart =
            (cfg.badges !== "1") ? "badges=off" :
            (cfg.badgeMode === "text") ? "badges=text" :
            (!credsPresent()) ? "badges=need-creds" :
            (badgeCache.loadedFor === cfg.channel) ? "badges=ok" : "badges=loading";
          setStatus(`online ✅ #${cfg.channel} • ${sevenPart} • ${badgePart}`);
        }

        if (line.includes(" PRIVMSG ")){
          const p = parsePrivmsg(line);
          if (!p) continue;

          addMessage({
            username: p.username,
            displayName: p.tags["display-name"] || p.username,
            tags: {
              color: p.tags.color || null,
              badges: parseBadges(p.tags.badges || "")
            },
            message: p.message,
            cfg
          });
        }
      }
    };

    ws.onerror = ()=>{
      if (token !== connToken) return;
      setStatus(`error ❌ websocket (waiting close)`);
    };

    ws.onclose = (e)=>{
      if (token !== connToken) return;
      clearTimers();
      detachAndClose();
      setStatus(`closed ❌ code=${e.code} (retrying)`);
      scheduleReconnect();
    };
  }

  // ==========================
  // UI wiring
  // ==========================
  $("menuToggle").addEventListener("click", ()=> $("menu").classList.toggle("open"));

  $("apply").addEventListener("click", async ()=>{
    const cfg = readMenu();
    writeHash(cfg);
    await connect(cfg);
  });

  $("reset").addEventListener("click", async ()=>{
    location.hash = "";
    const cfg = getConfig();
    fillMenu(cfg);
    await connect(cfg);
  });

  $("copy").addEventListener("click", copyUrl);

  $("hideMenu").addEventListener("click", ()=>{
    const base = location.origin + location.pathname + "?menu=0";
    location.href = base + location.hash;
  });

  $("showMenu").addEventListener("click", ()=>{
    const base = location.origin + location.pathname + "?menu=1";
    location.href = base + location.hash;
  });

  $("saveCreds").addEventListener("click", async ()=>{
    const clientId = $("twitchClientId").value.trim();
    const token = $("twitchToken").value.trim();
    if (!clientId || !token){
      setStatus("missing Client ID or Token");
      return;
    }
    setCreds(clientId, token);
    setStatus("creds saved (session) ✅");
  });

  $("clearCreds").addEventListener("click", ()=>{
    clearCreds();
    $("twitchClientId").value = "";
    $("twitchToken").value = "";
    setStatus("creds cleared ✅");
  });

  $("reloadBadges").addEventListener("click", async ()=>{
    const cfg = getConfig();
    if (!credsPresent()){
      setStatus("need creds to load badges");
      return;
    }
    try{
      setStatus("loading badges…");
      const b = await loadBadgesForChannel(cfg.channel);
      setStatus(`badges loaded ✅ (global sets ${b.globalSets}, channel sets ${b.channelSets})`);
    }catch(err){
      setStatus(`badge load failed ❌`);
      console.warn(err);
    }
  });

  // ==========================
  // Boot
  // ==========================
  const cfg0 = getConfig();
  fillMenu(cfg0);
  applyCss(cfg0);
  fillCredInputs();

  // Preview message
  addMessage({
    username:"chatbox",
    displayName:"Chatbox",
    tags:{ color:"#00e5ff", badges:{ broadcaster:"1" } },
    message:"Paste Client ID + App Token in ⚙️ → Save creds → Reload badges. 7TV status shows in the pill.",
    cfg: cfg0
  });

  // Hide menu if requested
  if ((qs.get("menu") ?? cfg0.menu) === "0") {
    $("menuToggle").style.display = "none";
    $("menu").style.display = "none";
  }

  connect(cfg0);
</script>
</body>
</html>
